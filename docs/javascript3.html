<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>JavaScript</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/branko.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">

        <section class="vcenter">
          <h1>JavaScript: dobre stvari</h1>
          <p>
            <small><a href="http://mbranko.github.io/webkurs">http://mbranko.github.io/webkurs</a></small>
          </p>
          <p>
            <small>Ovo je deo <a href="index.html#/1">web kursa</a></small>
          </p>
        </section>

        <section class="valigntop">
          <h2>Literatura</h2>
          <ul>
            <li>JavaScript Programmers Reference</li>
            <li>JavaScript: The Good Parts</a></li>
            <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide" target="_blank">JavaScript Guide</a> od Mozilla Developers Network.</li>
            <li><a href="http://www.codecademy.com/tracks/javascript" target="_blank">Code Academy</a> sa interaktivnim JavaScript lekcijama.</li>
            <li><a href="https://www.khanacademy.org/computing/cs/programming">Khan Academy</a> ima puno informacija o crtanju i animaciji.</li>
          </ul>
        </section>

        <section class="valigntop">
          <h2>Sadržaj</h2>
          <ol>
            <li><a href="#/cascades">Kaskade</a></li>
            <li><a href="#/callbacks">Callback</a></li>
            <li><a href="#/modules">Moduli</a></li>
            <li><a href="#/promises">Obećanja</a></li>
            <li><a href="#/webstorage">Web Storage</a></li>
            <li><a href="#/efficient">Efikasno učitavanje</a></li>
            <li><a href="#/cors">CORS</a></li>
          </ol>
        </section>

        <section id="cascades">
          <h1>#1: cascade</h1>
        </section>

        <section class="valigntop">
          <h2>Cascade</h2>
          <p class="left">Mogućnost da pozovemo više metoda prosleđujući im isti objekat:</p>
          <div style="font-size:30pt;"><pre><code class="javascript">str.replace("k", "R").toUpperCase().substr(0,4);</code></pre></div>
        </section>

        <section class="valigntop">
          <h2>Cascade: primer</h2>
          <div><pre><code class="javascript">
​var userController = {
  currentUser: "",
  findUser: function (userEmail) {
    var arrayLength = usersData.length, i;
    for (i = arrayLength - 1; i >= 0; i--) {
      if (usersData[i].email === userEmail) {
        this.currentUser = usersData[i];
        break;
      }
    }
    return this;
  },
  formatName: function () {
    if (this.currentUser) {
      this.currentUser.fullName = this.currentUser.firstName + " " + this.currentUser.lastName;
    }
    return this;
  },
  createLayout: function () {
    if (this.currentUser) {
      this.currentUser.viewData = "<h2>Member: " + this.currentUser.fullName + "</h2>"​
        + "<p>ID: " + this.currentUser.id + "</p>" + "<p>Email: " + this.currentUser.email + "</p>";
    }
    return this;
  },
};
          </code></pre></div>
          <p><small>Svaka funkcija vraća <code>this</code>.</small></p>
        </section>

        <section class="valigntop">
          <h2>Cascade: primer</h2>
          <p class="left">Primer pozivanja</p>
          <div style="font-size: 30pt;"><pre><code class="javascript">
​userController.findUser("test2@test2.com").formatName().createLayout().displayUser();
          </code></pre></div>
        </section>

        <section id="callbacks">
          <h1>#2: callback</h1>
        </section>

        <!-- sa FED kursa -->
        <section class="valigntop">
          <h2>Callback funkcija</h2>
          <ul>
            <li>koncept iz funkcionalnog programiranja</li>
            <li>funkcija kao parametar funkcije</li>
          </ul>
          <div style="font-size:30pt;"><pre><code class="javascript">
$("#btn_1").click(function() {
  alert("Btn 1 Clicked");
});          
          </code></pre></div>
          <div style="font-size:30pt;"><pre><code class="javascript">
var friends = ["Mike", "Stacy", "Andy", "Rick"];
​
friends.forEach(function (eachName, index){
  console.log(index + 1 + ". " + eachName); // 1. Mike, 2. Stacy, 3. Andy, 4. Rick​
});         
          </code></pre></div>
        </section>

        <section class="valigntop">
          <h2>Callback funkcija</h2>
          <ul>
            <li>prilikom poziva funkcije prosleđujemo definiciju druge funkcije</li>
            <li>ne izvršava se prilikom poziva<br/><br/></li>
            <li><strong>callback funkcija je closure</strong></li>
          </ul>
        </section>

        <section class="valigntop">
          <h2>Callback tip #1: anonimne i imenovane funkcije</h2>
          <p class="left">primer imenovane callback funkcije</p>
          <div style="font-size:30pt;"><pre><code class="javascript">
​var allUserData = [];
​
​function logStuff(userData) {
  if (typeof userData === "string")
    console.log(userData);
  else if (typeof userData === "object")
    for (var item in userData)
      console.log(item + ": " + userData[item]);
}
​
​function getInput(options, callback) {
  allUserData.push(options);
  callback(options);
}
​
​getInput ({name:"Rich", speciality:"JavaScript"}, logStuff);
​          </code></pre></div>
          <p class="left"><small>Callback funkcija prima parametar od funkcije koja je obuhvata.</small></p>
        </section>

        <section class="valigntop">
          <h2>Callback tip #2: prenos parametara</h2>
          <p class="left">callback može pristupiti globalnim promenljivima</p>
          <div style="font-size:30pt;"><pre><code class="javascript">
​​var defaultOptions = { ... };
​
​function logStuff(userData) {
  if (!userData)
    userData = defaultOptions;
  ...
}
          </code></pre></div>
        </section>

        <section class="valigntop">
          <h2>Callback tip #3: provera da li je callback</h2>
          <p class="left">pre poziva može se proveriti da li je u pitanju funkcija</p>
          <div style="font-size:30pt;"><pre><code class="javascript">
​​function getInput(options, callback) {
  allUserData.push(options);
​  if (typeof callback === "function")
    callback(options);
}
          </code></pre></div>
        </section>

        <section class="valigntop">
          <h2>Callback tip #4: pazi na this</h2>
          <p class="left">Kada je callback metoda koja koristi <code>this</code>:</p>
          <div style="font-size:30pt;"><pre><code class="javascript">
​​// definiši objekat sa metodom
​// metodu ćemo kasnije proslediti kao callback
​var clientData = {
  id: 094545,
  fullName: "Not Set",
  setUserName: function (firstName, lastName)  {
    this.fullName = firstName + " " + lastName;
  }
}
​
​function getUserInput(firstName, lastName, callback)  {
  callback (firstName, lastName);
}
          </code></pre></div>
          <p class="left">Kada se pozove <code>setUserName</code>, <code>this</code> se ne odnosi na objekat <code>clientData</code> nego na <code>window</code> objekat u web čitaču, jer je <code>getUserInput</code> globalna funkcija. U globalnoj funkciji <code>this</code> pokazuje na <code>window</code>.
        </section>

        <section class="valigntop">
          <h2>Callback tip #4: pazi na this</h2>
          <p class="left">Funkcije <code>call</code> i <code>apply</code> mogu da postave <code>this</code> unutar funkcije i proslede parametre funkciji. Obe funkcije primaju novu vrednost za <code>this</code> kao prvi parametar.</p>
          <p class="left">
          <div style="font-size:30pt;"><pre><code class="javascript">
​​// dodali smo novi parametar ovde: callbackObj
​function getUserInput(firstName, lastName, callback, callbackObj)  {
  callback.apply(callbackObj, [firstName, lastName]);
}
          </code></pre></div>
          <p class="left">Drugi parametar za <code>apply</code> je niz koji će se proslediti funkciji kao njeni parametri.</p>
          <p class="left">Naredni parametri za <code>call</code> su parametri koji će se direktno proslediti funkciji.</p>
        </section>

        <section class="valigntop">
          <h2>Callback tip #5: više callback funkcija odjednom</h2>
          <p class="left">Možemo proslediti više callback funkcija odjednom prilikom poziva.</p>
          <p class="left">
          <div style="font-size:30pt;"><pre><code class="javascript">
​​function successCallback() { ... }
​
​function successCallback() { ... }
​
​function completeCallback() { ... }
​
​function errorCallback() { ... }
​
$.ajax({
    url: "http://fiddle.jshell.net/favicon.png",
    success: successCallback,
    complete: completeCallback,
    error: errorCallback
});
          </code></pre></div>
          <p class="left"><small>Primer koristi jQuery <code>ajax</code> funkciju.</small></p>
        </section>

        <section class="valigntop">
          <h2>Callback Hell</h2>
          <p class="left">Callback poziva callback poziva callback poziva...</p>
          <div style="font-size:30pt;"><pre><code class="javascript">
var p_client = new Db('integration_tests_20', new Server("127.0.0.1", 27017, {}), {'pk':CustomPKFactory});
p_client.open(function(err, p_client) {
    p_client.dropDatabase(function(err, done) {
        p_client.createCollection('test_custom_key', function(err, collection) {
            collection.insert({'a':1}, function(err, docs) {
                collection.find({'_id':new ObjectID("aaaaaaaaaaaa")}, function(err, cursor) {
                    cursor.toArray(function(err, items) {
                        test.assertEquals(1, items.length);
​
                        // Let's close the db​
                        p_client.close();
                    });
                });
            });
        });
    });
});
          </code></pre></div>
          <p class="left"><small>Primer iz <a href="https://www.mongodb.com" target="_blank">MongoDB</a> drajvera za <a href="https://nodejs.org/" target="_blank">Node.js</a>.</small></p>
        </section>

        <section class="valigntop">
          <h2>Callback Hell</h2>
          <p class="left">Dva pristupa rešavanju ovog problema:</p>
          <ol>
            <li>Dati ime funkciji i proslediti samo ime funkcije kao callback, umesto pisanja anonimne funkcije unutar poziva.</li>
            <li>Podeliti kod u module, tako da se odgovarajući modul importuje u veću aplikaciju.</li>
          </ol>
        </section>

        <section id="modules">
          <h1>#3: moduli</h1>
        </section>

        <section class="valigntop">
          <h2>JavaScript nema module</h2>
          <ul>
            <li>Java ima pakete</li>
            <li>C# ima namespaces</li>
            <li>JavaScript ima samo <strong>globalni</strong> opseg i <strong>lokalni</strong> opseg</li>
            <li>nema nivoa između!</li>
          </ul>
        </section>

        <section class="valigntop">
          <h2>Koncept modula</h2>
          <ul>
            <li>smeštanje srodnih funkcija u poseban fajl</li>
            <li>sprečavanje kolizije imena</li>
            <li>pakovanje u module</li>
            <li>online katalog i distribucija modula (<a href="http://npmjs.org" target="_blank">NPM</a>)</li>
          </ul>
        </section>

        <section class="valigntop">
          <h2>Funkcija kao namespace</h2>
          <p class="left">Funkcija je jedina stvar u JavaScriptu koja pravi novi opseg. Pogledajmo primer...</p>
          <div style="font-size: 30pt;"><pre><code class="javascript">
​var names = ["Sunday", "Monday", "Tuesday", "Wednesday",
             "Thursday", "Friday", "Saturday"];

function dayName(number) {
  return names[number];
}

console.log(dayName(1)); // → Monday
          </code></pre></div>
        </section>

        <section class="valigntop">
          <h2>Funkcija kao namespace</h2>
          <p class="left">... kada se malo preradi:</p>
          <div style="font-size: 30pt;"><pre><code class="javascript">
​var dayName = function() {
  var names = ["Sunday", "Monday", "Tuesday", "Wednesday",
               "Thursday", "Friday", "Saturday"];
  return function(number) {
    return names[number];
  };
}();

console.log(dayName(3)); // → Wednesday
          </code></pre></div>
          <p class="left"><code>names</code> je sada lokalna promenljiva. Ova funkcija se kreira i odmah poziva, a njen rezultat je funkcija koja se smešta u promenljivu <code>dayName</code>. Ovde može biti hiljade linija koda sa puno lokalnih promenljivih; one bi bile vidljive samo u našoj funkciji ali ne i spolja.</p>
        </section>

        <section class="valigntop">
          <h2>Funkcija kao namespace</h2>
          <p class="left">Sada hoćemo da vratimo dve funkcije! Moramo ih spakovati u objekat:</p>
          <div style="font-size: 30pt;"><pre><code class="javascript">
​var weekDay = function() {
  var names = ["Sunday", "Monday", "Tuesday", "Wednesday",
               "Thursday", "Friday", "Saturday"];
  return {
    name: function(number) { return names[number]; },
    number: function(name) { return names.indexOf(name); }
  };
}();

console.log(weekDay.name(weekDay.number("Sunday"))); // → Sunday
          </code></pre></div>
          <p class="left">Za veće module, sakupljanje svih vrednosti u objekat na kraju funkcije može biti nečitko. Želimo da eksportovane funkcije definišemo na zgodnijem mestu.</p>
        </section>

        <section class="valigntop">
          <h2>Funkcija kao namespace</h2>
          <p class="left">Deklarišemo objekat i dodajemo osobine u njega kad god imamo nešto za eksport.</p>
          <div style="font-size: 30pt;"><pre><code class="javascript">
​(function(exports) {
  var names = ["Sunday", "Monday", "Tuesday", "Wednesday",
               "Thursday", "Friday", "Saturday"];

  exports.name = function(number) {
    return names[number];
  };
  exports.number = function(name) {
    return names.indexOf(name);
  };
})(this.weekDay = {});

console.log(weekDay.name(weekDay.number("Saturday"))); // → Saturday
          </code></pre></div>
          <p class="left">Samo jedna promenljiva u globalnom opsegu - <code>weekDay</code>. Ali šta ako
          dva modula koriste isto ime za globalnu promenljivu?</p>
        </section>

        <section class="valigntop">
          <h2>Funkcija kao namespace</h2>
          <p class="left">Deklarišemo objekat i dodajemo osobine u njega kad god imamo nešto za eksport.</p>
          <div style="font-size: 30pt;"><pre><code class="javascript">
​(function(exports) {
  var names = ["Sunday", "Monday", "Tuesday", "Wednesday",
               "Thursday", "Friday", "Saturday"];

  exports.name = function(number) {
    return names[number];
  };
  exports.number = function(name) {
    return names.indexOf(name);
  };
})(this.weekDay = {});

console.log(weekDay.name(weekDay.number("Saturday"))); // → Saturday
          </code></pre></div>
          <p class="left">Samo jedna promenljiva u globalnom opsegu - <code>weekDay</code>. Ali šta ako
          dva modula koriste isto ime za globalnu promenljivu?</p>
        </section>

        <section class="valigntop">
          <h2>Sudari u globalnom opsegu</h2>
          <ul>
            <li>hoćemo da napravimo funkciju <code>require</code> koja će, za dato ime modula, da ga učita iz fajla ili sa weba i vratiti odgovarajuću vrednost</li>
            <li>rešava prethodni problem i sprečava da koristimo modul bez eksplicitnog uvoženja</li>
            <li>moramo biti u stanju da učitani string izvršimo kao JavaScript kod u funkciji <code>require</code></li>
          </ul>
        </section>

        <section class="valigntop">
          <h2>Izvršavanje koda iz stringa</h2>
          <p class="left">Prost način: upotreba <code>eval</code>.</p>
          <div style="font-size: 30pt;"><pre><code class="javascript">
​function evalAndReturnX(code) {
  eval(code);
  return x;
}

console.log(evalAndReturnX("var x = 2")); // → 2
          </code></pre></div>
          <p class="left">Za nevolju, <code>eval</code> će rezultate izvršavanja upisati u <strong>tekući</strong> opseg.</p>
        </section>

        <section class="valigntop">
          <h2>Izvršavanje koda iz stringa</h2>
          <p class="left">Bolji način: pomoću <code>Function</code> konstruktora. On prima dva argumenta: string sa nazivima parametara funkcije razdvojenih zarezima i string sa telom funkcije.</p>
          <div style="font-size: 30pt;"><pre><code class="javascript">
​var plusOne = new Function("n", "return n + 1;");
console.log(plusOne(4)); // → 5
          </code></pre></div>
          <p class="left">Pri kraju smo: umotaćemo kod modula u funkciju, i ta funkcija postaje opseg za naš modul.</p>
        </section>

        <section class="valigntop">
          <h2>Funkcija require</h2>
          <p class="left">Minimalna implementacija za <code>require</code>: </p>
          <div style="font-size: 30pt;"><pre><code class="javascript">
​function require(name) {
  var code = new Function("exports", readFile(name));
  var exports = {};
  code(exports);
  return exports;
}

console.log(require("weekDay").name(1)); // → Monday
          </code></pre></div>
          <p class="left">Pošto funkcija <code>require</code> umotava kod u funkciju, nema potrebe da to radimo u modulu.</p>
        </section>

        <section class="valigntop">
          <h2>Primer modula za require</h2>
          <p class="left">Sada fajl sa modulom može ovako da izgleda:</p>
          <div style="font-size: 30pt;"><pre><code class="javascript">
​var names = ["Sunday", "Monday", "Tuesday", "Wednesday",
             "Thursday", "Friday", "Saturday"];

exports.name = function(number) {
  return names[number];
};
exports.number = function(name) {
  return names.indexOf(name);
};
          </code></pre></div>
        </section>

        <section class="valigntop">
          <h2>Tipičan modul</h2>
          <p class="left">Tipičan modul će na vrhu učitati module koji su mu potrebni:</p>
          <div style="font-size: 30pt;"><pre><code class="javascript">
​var weekDay = require("weekDay");
var today = require("today");

console.log(weekDay.name(today.dayNumber()));
          </code></pre></div>
          <ul>
            <li>Ovakav <code>require</code> će izvršiti kod modula svaki put kad se učitava.</li> 
            <li>Nije moguće eksportovati ništa osim <code>exports</code> objekta (npr. funkciju).</li>
          </ul>
        </section>

        <section class="valigntop">
          <h2>CommonJS</h2>
          <p class="left">Moduli će dobiti promenljivu <code>module</code> koja je objekat sa osobinom <code>exports</code>. Ova osobina inicijalno pokazuje na <code>{}</code> koji je kreirao <code>require</code>.</p>
          <div style="font-size: 30pt;"><pre><code class="javascript">
​function require(name) {
  if (name in require.cache)
    return require.cache[name];

  var code = new Function("exports, module", readFile(name));
  var exports = {}, module = {exports: exports};
  code(exports, module);

  require.cache[name] = module.exports;
  return module.exports;
}
require.cache = Object.create(null);
          </code></pre></div>
          <ul>
            <li>ovakav stil rada sa modulima zove se CommonJS</li>
            <li>koristi ga i <a href="https://nodejs.org" target="_blank">Node.js</a></li>
          </ul>
        </section>

        <section class="valigntop">
          <h2>AMD</h2>
          <ul>
            <li>učitavanje modula sa weba može biti sporo...</li>
            <li>...rešenje: umotaj modul u funkciju tako da se u pozadini obavi
              <ol>
                <li>učitavanje drugih potrebnih modula</li>
                <li>inicijalizacija modula pozivom te funkcije</li>
            </ol>
            </li>
            <li>to se naziva AMD (Asynchronous Module Definition)</li>
          </ul>
        </section>

        <section class="valigntop">
          <h2>Upotreba AMD modula</h2>
          <div style="font-size: 30pt;"><pre><code class="javascript">
​define(["weekDay", "today"], function(weekDay, today) {
  console.log(weekDay.name(today.dayNumber()));
});
          </code></pre></div>
          <p class="left">
          Funkcija <code>define</code> prima niz sa nazivima modula i zatim funkciju koja prima po jedan parametar za svaki modul. Učitaće module u pozadini dok stranica radi. Kada su svi moduli učitani pozvaće datu funkciju koja će obaviti inicijalizaciju.
          </p>
        </section>

        <section class="valigntop">
          <h2>Upotreba AMD modula</h2>
          <p>Nova verzija našeg modula:</p>
          <div style="font-size: 30pt;"><pre><code class="javascript">
​define([], function() {
  var names = ["Sunday", "Monday", "Tuesday", "Wednesday",
               "Thursday", "Friday", "Saturday"];
  return {
    name: function(number) { return names[number]; },
    number: function(name) { return names.indexOf(name); }
  };
});
          </code></pre></div>
          <p class="left">
          Funkcija <code>define</code> prima niz sa nazivima modula i zatim funkciju koja prima po jedan parametar za svaki modul. Učitaće module u pozadini dok stranica radi. Kada su svi moduli učitani pozvaće datu funkciju koja će obaviti inicijalizaciju.
          </p>
        </section>

        <section class="valigntop">
          <h2>Implementacija AMD</h2>
          <p>Funkcija <code>getModule</code> će učitati modul ili ga izvući iz keša.</p>
          <div style="font-size: 30pt;"><pre><code class="javascript">
​var defineCache = Object.create(null);
var currentMod = null;

function getModule(name) {
  if (name in defineCache)
    return defineCache[name];

  var module = {exports: null,
                loaded: false,
                onLoad: []};
  defineCache[name] = module;
  backgroundReadFile(name, function(code) {
    currentMod = module;
    new Function("", code)();
  });
  return module;
}
          </code></pre></div>
          <p class="left"><small>
          Funkcija <code>backgroundReadFile</code> nije jednostavna.</small>
          </p>
        </section>

        <section class="valigntop">
          <h2>Implementacija AMD</h2>
          <p>Funkcija <code>define</code> će pozvati inicijalizaciju modula kada prikupi sve potrebne module.</p>
          <div style="font-size: 26pt;"><pre><code class="javascript">
​function define(depNames, moduleFunction) {
  var myMod = currentMod;
  var deps = depNames.map(getModule);

  deps.forEach(function(mod) {
    if (!mod.loaded)
      mod.onLoad.push(whenDepsLoaded);
  });

  function whenDepsLoaded() {
    if (!deps.every(function(m) { return m.loaded; }))
      return;

    var args = deps.map(function(m) { return m.exports; });
    var exports = moduleFunction.apply(null, args);
    if (myMod) {
      myMod.exports = exports;
      myMod.loaded = true;
      myMod.onLoad.forEach(function(f) { f(); });
    }
  }
  whenDepsLoaded();
}
          </code></pre></div>
        </section>

        <section class="valigntop">
          <h2>RequireJS</h2>
          <p class="left">Funkcija <code>define</code> će učitati modul ili ga izvući iz keša pomoću <code>getModule</code>. Njen zadatak je da se <code>moduleFunction</code> (funkcija koja sadrži kod modula) pozove kada su učitani svi potrebni moduli. Zato definiše <code>whenDepsLoaded</code> koja se dodaje na kraj <code>onLoad</code> niza svih trenutno nedostajućih modula. Ova funkcija se odmah vraća ako ima još neučitanih modula. Tako će se posao obaviti samo jednom, kada se učita i poslednji modul. Poziva se i direktno iz <code>define</code> ako tekući modul nema potrebnih modula.</p>

          <p class="left">Kada su svi potrebni moduli dostupni, <code>whenDepsLoaded</code> poziva funkciju koja obmotava modul dajući joj sve tražene module kao parametre.</p>

          <p class="left"><a href="http://requirejs.org" target="_blank">RequireJS</a> radi na ovaj način.</p>

        </section>

        <section id="promises">
          <h1>#4: obećanja</h1>
        </section>

        <section class="valigntop left">
          <h2>Promise objekti</h2>
          <p class="left">Implementirani u posebnim bibliotekama od ranije, npr:</p>
          <ul class="left">
            <li><a href="https://github.com/kriskowal/q" target="_blank">Q</a></li>
            <li><a href="https://github.com/cujojs/when" target="_blank">when</a></li>
            <li><a href="https://msdn.microsoft.com/en-us/library/windows/apps/br211867.aspx" target="_blank">WinJS</a></li>
            <li><a href="https://github.com/tildeio/rsvp.js" target="_blank">RSVP.js</a></li>
          </ul>

          <p class="left">Podrška u web čitačima:</p>
          <ul>
            <li>Chrome 32</li>
            <li>Firefox 29</li>
            <li>Safari 8</li>
            <li>Microsoft Edge</li>
          </ul>

          <p class="left">Ili ovaj <a href="https://github.com/stefanpenner/es6-promise#readme" target="_blank">polyfill</a> za starije čitače.</p>
          <p class="left">Uvedeni u ECMAScript 6.</p>
        </section>

        <section class="valigntop left">
          <h2>Promise definicija</h2>
          <p class="left">Promise je proxy za vrednost koju ne moramo znati u vreme kreiranja. Može biti u tri stanja:</p>
          <ul>
            <li><strong>pending</strong>: inicijalno stanje, niti ispunjeno niti odbijeno</li>
            <li><strong>fulfilled</strong>: operacija je uspešno završena</li>
            <li><strong>rejected</strong>: operacija nije uspešno završena<br/><br/></li>
            <li><strong>settled</strong>: fulfilled ili rejected</li>
          </ul>
        </section>

        <section class="valigntop">
          <h2>Primer</h2>
          <div style="font-size: 30pt;"><pre><code class="javascript">
​var img1 = document.querySelector('.img-1');

img1.addEventListener('load', function() {
  // ...
});

img1.addEventListener('error', function() {
  // ...
});
          </code></pre></div>
          <p class="left">Događaj može da se desi pre nego što počnemo da ga osluškujemo!</p>
        </section>

        <section class="valigntop">
          <h2>Primer</h2>
          <p>Da probamo da iskoristimo osobinu <code>complete</code> za slike:</p>
          <div style="font-size: 26pt;"><pre><code class="javascript">
​var img1 = document.querySelector('.img-1');

function loaded() {
  // ...
}

if (img1.complete) {
  loaded();
}
else {
  img1.addEventListener('load', loaded);
}

img1.addEventListener('error', function() {
  // ...
});
          </code></pre></div>
          <p class="left">Ne hvata slike koje su proizvele grešku pre nego što smo počeli da slušamo.</p>
          <p class="left">Ako treba da obradimo više slika...</p>
        </section>

        <section class="valigntop">
          <h2>Primer</h2>
          <p>Idealno nam treba nešto ovakvo:</p>
          <div style="font-size: 30pt;"><pre><code class="javascript">
​img1.callThisIfLoadedOrWhenLoaded(function() {
  // loaded
}).orIfFailedCallThis(function() {
  // failed
});

whenAllTheseHaveLoaded([img1, img2]).callThis(function() {
  // all loaded
}).orIfSomeFailedCallThis(function() {
  // one or more failed
});
          </code></pre></div>
          <p class="left">Ovaj problem rešavaju <strong>promise objekti</strong>.</p>
        </section>

        <section class="valigntop">
          <h2>Primer</h2>
          <p>Kada bi <code>img</code> element imao <code>ready</code> metodu koja vraća promise:</p>
          <div style="font-size: 30pt;"><pre><code class="javascript">
​img1.ready().then(function() {
  // loaded
}, function() {
  // failed
});

Promise.all([img1.ready(), img2.ready()]).then(function() {
  // all loaded
}, function() {
  // one or more failed
});
          </code></pre></div>
        </section>

        <section class="valigntop left">
          <h2>Primer</h2>
          <p class="left">Promise - slično osluškivanju događaja osim:</p>
          <ol>
            <li>Promise može biti uspešan ili neuspešan <strong>jednom</strong>. Ne može dva puta, niti se može menjati status iz uspešnog u neuspešno ili obrnuto.</li>
            <li>Ako je promise bio uspešan ili neuspešan, a kasnije smo dodali callback funkcije, odgovarajući callback će biti pozvan iako se događaj desio pre toga.</li>
          </ol>
        </section>

        <section class="valigntop">
          <h2>Promise: kreiranje</h2>
          <p class="left">Ovako se kreira promise:</p>
          <div style="font-size: 30pt;"><pre><code class="javascript">
​var promise = new Promise(function(resolve, reject) {
  // uradi neki posao

  if (/* sve je u redu? */) {
    resolve("Radi!");
  } else {
    reject(Error("Ne radi!"));
  }
});
          </code></pre></div>
        </section>

        <section class="valigntop">
          <h2>Promise: korišćenje</h2>
          <p class="left">A ovako se koristi:</p>
          <div style="font-size: 30pt;"><pre><code class="javascript">
​promise.then(function(result) {
  console.log(result); // "Radi!"
}, function(err) {
  console.log(err); // Error: "Ne radi!"
});
          </code></pre></div>
        </section>

        <section class="valigntop left">
          <h2>then()</h2>
          <p class="left"><code>then</code> prima dva parametra</p>
          <ol>
            <li>callback za uspešan ishod</li>
            <li>callback za neuspešan ishod</li>
          </ol>
        </section>

        <section class="valigntop left">
          <h2>Primer</h2>
          <p class="left">Naša stranica bi trebalo da:</p>
          <ol>
            <li>pokrene spinner da prikaže učitavanje</li>
            <li>učita JSON za knjigu (što nam daje naslov i URI-je za svako poglavlje)</li>
            <li>postavi naslov stranice</li>
            <li>učita sva poglavlja</li>
            <li>doda knjigu na stranicu</li>
            <li>zaustavi spinner</li>
          </ol>
          <p class="left">U slučaju greške treba obavestiti korisnika i zaustaviti spinner.</p>
        </section>

        <section class="valigntop">
          <h2>Promisify XMLHttpRequest</h2>
          <div style="font-size: 28pt;"><pre><code class="javascript">​function get(url) {
  return new Promise(function(resolve, reject) {
    var req = new XMLHttpRequest();
    req.open('GET', url);

    req.onload = function() {
      if (req.status == 200)
        // uspešan ishod
        resolve(req.response);
      else
        // neuspešan ishod
        reject(Error(req.statusText));
    };

    // mrežne greške
    req.onerror = function() {
      reject(Error("Network Error"));
    };

    // pošalji zahtev
    req.send();
  });
}</code></pre></div>
        </section>

        <section class="valigntop">
          <h2>Promisify XMLHttpRequest</h2>
          <p class="left">Korišćenje prethodno napravljenog promise:</p>
          <div style="font-size: 30pt;"><pre><code class="javascript">​
get('story.json').then(function(response) {
  console.log("Success!", response);
}, function(error) {
  console.error("Failed!", error);
})
</code></pre></div>
        </section>

        <section class="valigntop">
          <h2>Ulančavanje then</h2>
          <p class="left">Rezultat učitavanja će biti JSON tekst koji treba parsirati:</p>
          <div style="font-size: 30pt;"><pre><code class="javascript">​
get('story.json').then(function(response) {
  return JSON.parse(response);
}).then(function(response) {
  console.log("Yey JSON!", response);
})
</code></pre></div>
          <p class="left">Pošto <code>JSON.parse</code> prima jedan parametar, to može i kraće:</p>
          <div style="font-size: 30pt;"><pre><code class="javascript">​
get('story.json').then(JSON.parse).then(function(response) {
  console.log("Yey JSON!", response);
})
</code></pre></div>
        </section>

        <section class="valigntop left">
          <h2>Ulančavanje then</h2>
          <p class="left">Ako callback vrati</p>
          <ul>
            <li>gotovu vrednost: sledeći <code>then</code> će je preuzeti</li>
            <li>promise: sledeći <code>then</code> će je sačekati</li>
          </ul>
          <div style="font-size: 30pt;"><pre><code class="javascript">​
getJSON('story.json').then(function(story) {
  return getJSON(story.chapterUrls[0]);
}).then(function(chapter1) {
  console.log("Got chapter 1!", chapter1);
})
</code></pre></div>
        </section>

        <section class="valigntop left">
          <h2>Hvatanje greške</h2>
          <p class="left"><code>then</code> prima dva parametra:</p>
          <div style="font-size: 30pt;"><pre><code class="javascript">​
get('story.json').then(function(response) {
  console.log("Success!", response);
}, function(error) {
  console.log("Failed!", error);
})
</code></pre></div>
          <p class="left">Može i pomoću <code>catch</code>:</p>
          <div style="font-size: 30pt;"><pre><code class="javascript">​
get('story.json').then(function(response) {
  console.log("Success!", response);
}).catch(function(error) {
  console.log("Failed!", error);
})
</code></pre></div>
          <p class="left">Ali to nije baš isto!</p>
        </section>

        <section class="valigntop left">
          <h2>Hvatanje greške</h2>
          <p class="left">Kada se koristi <code>catch</code>:</p>
          <div style="font-size: 30pt;"><pre><code class="javascript">​
get('story.json').then(function(response) {
  console.log("Success!", response);
}).catch(function(error) {
  console.log("Failed!", error);
})
</code></pre></div>
          <p class="left">je ekvivalentno sa:</p>
          <div style="font-size: 30pt;"><pre><code class="javascript">​
get('story.json').then(function(response) {
  console.log("Success!", response);
}).then(undefined, function(error) {
  console.log("Failed!", error);
})
</code></pre></div>
        </section>

        <section class="valigntop left">
          <h2>Hvatanje greške</h2>
          <p class="left">Sa <code>then(f1, f2)</code>, biće pozvana ili <code>f1</code> ili <code>f2</code>, nikada obe.</p>
          <p class="left">Sa <code>then(f1).catch(f2)</code>, biće pozvane obe i ako <code>f1</code> proizvede grešku jer su to posebni koraci u lancu.</p>
        </section>

        <section class="valigntop left">
          <h2>Izuzeci i promise</h2>
          <p class="left">Negativan ishod za promise dobija se</p>
          <ul>
            <li>eksplicitno, pozivanjem <code>reject</code> callback-a</li>
            <li>bacanjem izuzetka u konstruktoru promise-a, kao u primeru:</li>
          </ul>
          <div style="font-size: 30pt;"><pre><code class="javascript">​
var jsonPromise = new Promise(function(resolve, reject) {
  // JSON.parse baca grešku ako tekst nije pravilan JSON
  // tako da se ovo implicitno reject-uje
  resolve(JSON.parse("This ain't JSON"));
});

jsonPromise.then(function(data) {
  // nikad se neće desiti
  console.log("It worked!", data);
}).catch(function(err) {
  // ovo će se desiti
  console.log("It failed!", err);
})
          </code></pre></div>
        </section>

        <section class="valigntop left">
          <h2>Izuzeci i promise</h2>
          <p class="left">Isto važi i za greške koje nastanu u callbacku za <code>then</code>:</p>
          <div style="font-size: 30pt;"><pre><code class="javascript">​
get('/').then(JSON.parse).then(function() {
  // Ovo se neće desiti, '/' je HTML strana, ne JSON
  // pa će JSON.parse baciti izuzetak
  console.log("It worked!", data);
}).catch(function(err) {
  // ovo će se desiti
  console.log("It failed!", err);
})
          </code></pre></div>
        </section>

        <section class="valigntop left">
          <h2>Primer</h2>
          <p class="left">U primeru sa učitavanjem knjige:</p>
          <div style="font-size: 30pt;"><pre><code class="javascript">​
getJSON('book.json').then(function(book) {
  return getJSON(book.chapterUrls[0]);
}).then(function(chapter1) {
  addHtmlToPage(chapter1.html);
}).catch(function() {
  addTextToPage("Failed to show chapter");
}).then(function() {
  document.querySelector('.spinner').style.display = 'none';
})
          </code></pre></div>
          <p class="left"><small>Ako <code>getJSON(book.chapterUrls[0])</code> vrati grešku, preskaču sve svi <code>then</code> callbacks, i prelazi na <code>catch</code> callback. Spinner će se isključiti u oba slučaja.</small></p>
        </section>

        <section class="valigntop left">
          <h2>Primer</h2>
          <p class="left">Prethodni primer je asinhrona varijanta sledeće ideje:</p>
          <div style="font-size: 30pt;"><pre><code class="javascript">​
try {
  var story = getJSONSync('story.json');
  var chapter1 = getJSONSync(story.chapterUrls[0]);
  addHtmlToPage(chapter1.html);
} catch (e) {
  addTextToPage("Failed to show chapter");
}
document.querySelector('.spinner').style.display = 'none'
          </code></pre></div>
        </section>

        <section class="valigntop left">
          <h2>Primer</h2>
          <p class="left">Ako koristimo <code>catch</code> samo da zabeležimo grešku ali nastavljamo rad:</p>
          <div style="font-size: 30pt;"><pre><code class="javascript">​
function getJSON(url) {
  return get(url).then(JSON.parse).catch(function(err) {
    console.log("getJSON failed for", url, err);
    throw err;
  });
}
          </code></pre></div>
          <p class="left"><small>Ponovo bacimo grešku.</small></p>
        </section>

        <section class="valigntop left">
          <h2>Paralelizam i sekvenca</h2>
          <p class="left">Počnimo od sinhrone varijante koja učitava sva poglavlja:</p>
          <div style="font-size: 30pt;"><pre><code class="javascript">​
try {
  var story = getJSONSync('story.json');
  addHtmlToPage(story.heading);

  story.chapterUrls.forEach(function(chapterUrl) {
    var chapter = getJSONSync(chapterUrl);
    addHtmlToPage(chapter.html);
  });

  addTextToPage("All done");
}
catch (err) {
  addTextToPage("Argh, broken: " + err.message);
}

document.querySelector('.spinner').style.display = 'none'
          </code></pre></div>
          <p class="left"><small>Sinhrono izvršavanje će blokirati web čitač dok traje download.</small></p>
        </section>

        <section class="valigntop left">
          <h2>Paralelizam i sekvenca</h2>
          <p class="left">Počnimo od sinhrone varijante koja učitava sva poglavlja:</p>
          <div style="font-size: 30pt;"><pre><code class="javascript">​
try {
  var story = getJSONSync('story.json');
  addHtmlToPage(story.heading);

  story.chapterUrls.forEach(function(chapterUrl) {
    var chapter = getJSONSync(chapterUrl);
    addHtmlToPage(chapter.html);
  });

  addTextToPage("All done");
}
catch (err) {
  addTextToPage("Argh, broken: " + err.message);
}

document.querySelector('.spinner').style.display = 'none'
          </code></pre></div>
          <p class="left"><small>Sinhrono izvršavanje će blokirati web čitač dok traje download.</small></p>
        </section>

        <section class="valigntop left">
          <h2>Paralelizam i sekvenca</h2>
          <p class="left">Asinhrona varijanta bi trebalo da izgleda ovako:</p>
          <div style="font-size: 30pt;"><pre><code class="javascript">​
getJSON('story.json').then(function(story) {
  addHtmlToPage(story.heading);

  // TODO: za svaki url u story.chapterUrls, dobavi i prikaži ga
}).then(function() {
  // završili smo
  addTextToPage("All done");
}).catch(function(err) {
  // uhvati usputne greške
  addTextToPage("Argh, broken: " + err.message);
}).then(function() {
  // uvek
  document.querySelector('.spinner').style.display = 'none';
})
          </code></pre></div>
        </section>

        <section class="valigntop left">
          <h2>Paralelizam i sekvenca</h2>
          <p class="left">Ali kako da prođemo kroz poglavlja i učitavamo ih u pravom redosledu? Ovo neće raditi:</p>
          <div style="font-size: 30pt;"><pre><code class="javascript">​
story.chapterUrls.forEach(function(chapterUrl) {
  // dobavi poglavlje
  getJSON(chapterUrl).then(function(chapter) {
    // dodaj ga na stranicu
    addHtmlToPage(chapter.html);
  });
})
          </code></pre></div>
          <p class="left"><small><code>forEach</code> nije async-aware, tj. ne vodi računa o završetku operacije za svaki element sekvence. Poglavlja će se pojavljivati redosledu dobavljanja umesto u pravom redosledu.</small></p>
        </section>

        <section class="valigntop left">
          <h2>Paralelizam i sekvenca</h2>
          <p class="left">Treba da pretvorimo <code>chapterUrls</code> u listu promisa.</p>
          <div style="font-size: 30pt;"><pre><code class="javascript">​
// počni od promisa koji je uvek uspešan
var sequence = Promise.resolve();

// iteracija kroz chapterUrls
story.chapterUrls.forEach(function(chapterUrl) {
  // dodaj ove akcije na kraj sekvence
  sequence = sequence.then(function() {
    return getJSON(chapterUrl);
  }).then(function(chapter) {
    addHtmlToPage(chapter.html);
  });
})
          </code></pre></div>
        </section>

        <section class="valigntop left">
          <h2>Paralelizam i sekvenca</h2>
          <p class="left">Ovo može i pomoću <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" target="_blank"><code>Array.reduce</code></a>:</p>
          <div style="font-size: 30pt;"><pre><code class="javascript">​
// iteracija kroz chapterUrls
story.chapterUrls.reduce(function(sequence, chapterUrl) {
  // dodaj ove akcije na kraj sekvence
  return sequence.then(function() {
    return getJSON(chapterUrl);
  }).then(function(chapter) {
    addHtmlToPage(chapter.html);
  });
}, Promise.resolve())
          </code></pre></div>
          <p class="left"><small>Ne treba nam posebna promenljiva.</small></p>
        </section>

        <section class="valigntop left">
          <h2>Paralelizam i sekvenca</h2>
          <p class="left">Rešenje:</p>
          <div style="font-size: 27pt;"><pre><code class="javascript">​getJSON('story.json').then(function(story) {
  addHtmlToPage(story.heading);

  return story.chapterUrls.reduce(function(sequence, chapterUrl) {
    // kada je završio promise prethodnog poglavlja
    return sequence.then(function() {
      // dobavi sledeće poglavlje
      return getJSON(chapterUrl);
    }).then(function(chapter) {
      // i dodaj ga na stranicu
      addHtmlToPage(chapter.html);
    });
  }, Promise.resolve());
}).then(function() {
  // sve je gotovo
  addTextToPage("All done");
}).catch(function(err) {
  // uhvati greške usput
  addTextToPage("Argh, broken: " + err.message);
}).then(function() {
  // uvek skloni spinner na kraju
  document.querySelector('.spinner').style.display = 'none';
})</code></pre></div>
        </section>

        <section class="valigntop left">
          <h2>Promise.all</h2>
          <p class="left">Zašto da radimo download sekvencijalno? Postoji API:</p>
          <div style="font-size: 30pt;"><pre><code class="javascript">​
Promise.all(arrayOfPromises).then(function(arrayOfResults) {
  //...
})
          </code></pre></div>
          <p class="left"><code>Promise.all</code> prima niz promisa i kreira promise koji je ispunjen kada se svi uspešno završe. Dobija se niz rezultata u redosledu koji odgovara redosledu promisa.</p>
        </section>

        <section class="valigntop left">
          <h2>Paralelizam i sekvenca</h2>
          <p class="left"><code>Promise.all</code> primenjeno na naš problem:</p>
          <div style="font-size: 27pt;"><pre><code class="javascript">​getJSON('story.json').then(function(story) {
  addHtmlToPage(story.heading);

  // kreiraj niz promisa i čekaj na sve njih
  return Promise.all(
    // mapiraj chapterUrls niz na niz JSON promisa
    story.chapterUrls.map(getJSON)
  );
}).then(function(chapters) {
  // sada imamo JSON-e u pravom redosledu, iteriramo kroz njih
  chapters.forEach(function(chapter) {
    // i dodajemo u stranicu
    addHtmlToPage(chapter.html);
  });
  addTextToPage("All done");
}).catch(function(err) {
  // uhvati greške usput
  addTextToPage("Argh, broken: " + err.message);
}).then(function() {
  document.querySelector('.spinner').style.display = 'none';
})</code></pre></div>
        </section>

        <section class="valigntop left">
          <h2>Paralelizam i sekvenca</h2>
          <p class="left">Kada stigne poglavlje 1 možemo ga dodati na stranicu.</p>
          <p class="left">Kada stigne poglavlje 3 ne možemo ga dodati na stranicu jer nije još stiglo poglavlje 2.</p>
          <p class="left">Kada stigne poglavlje 2 možemo dodati poglavlja 2 i 3 na stranicu.<br/><br/></p>
          <p class="left">Dobavićemo sva poglavlja paralelno, ali ćemo kreirati sekvencu za dodavanje u stranicu.</p>
        </section>

        <section class="valigntop left">
          <h2>Paralelizam i sekvenca</h2>
          <p class="left">Paralelni download, sekvencijalno dodavanje u stranicu:</p>
          <div style="font-size: 27pt;"><pre><code class="javascript">​getJSON('story.json').then(function(story) {
  addHtmlToPage(story.heading);

  // Mapiraj niz chapterUrls na niz JSON promisa. Oni će se dobavljati paralelno.
  return story.chapterUrls.map(getJSON)
    .reduce(function(sequence, chapterPromise) {
      // pomoću reduce ćemo ulančati promise, dodajući sadržaj na stranicu za svako poglavlje
      return sequence.then(function() {
        // sačekaj na sve u sekvenci, onda sačekaj na poglavlje
        return chapterPromise;
      }).then(function(chapter) {
        addHtmlToPage(chapter.html);
      });
    }, Promise.resolve());
}).then(function() {
  addTextToPage("All done");
}).catch(function(err) {
  addTextToPage("Argh, broken: " + err.message);
}).then(function() {
  document.querySelector('.spinner').style.display = 'none';
})</code></pre></div>
        </section>

        <section id="webstorage">
          <h1>#5: web storage</h1>
        </section>

        <section class="valigntop">
          <h2>HTML5 Web Storage</h2>
          <ul>
            <li>jednostavna baza podataka u web čitaču</li>
            <li>čuva parove ključ-vrednost</li>
            <li>do 10MB po domenu</li>
            <li>podrška u savremenim čitačima</li>
          </ul>
        </section>

        <section class="valigntop">
          <h2>Vrste web storage</h2>
          <ul>
            <li><strong>local storage</strong>: trajno čuva podatke</li>
            <li><strong>session storage</strong>: čuva podatke u toku sesije; gubi se po zatvaranju čitača</li>
          </ul>
        </section>


        <section class="valigntop left">
          <h2>Primer: forma</h2>
          <p class="left">Forma za unos podataka</p>
          <div style="font-size: 30pt;"><pre><code class="html">​
&lt;section&gt;
  &lt;form onsubmit=&quot;javascript:setSettings()&quot;&gt;
    &lt;label&gt;Select your BG color: &lt;/label&gt;
    &lt;input id=&quot;favcolor&quot; type=&quot;color&quot; value=&quot;#ffffff&quot; /&gt;
    &lt;label&gt;Select Font Size: &lt;/label&gt;
    &lt;input id=&quot;fontwt&quot; type=&quot;number&quot; max=&quot;14&quot; min=&quot;10&quot; value=&quot;13&quot; /&gt;
    &lt;input type=&quot;submit&quot; value=&quot;Save&quot; /&gt;
    &lt;input onclick=&quot;clearSettings()&quot; type=&quot;reset&quot; value=&quot;Clear&quot; /&gt;
  &lt;/form&gt;
&lt;/section&gt; 
          </code></pre></div>
        </section>

        <section class="valigntop left">
          <h2>Primer: test podrške u web čitaču</h2>
          <p class="left">Test podrške za local storage:</p>
          <div style="font-size: 30pt;"><pre><code class="javascript">​
function setSettings() {
  if ('localStorage' in window &amp;&amp; window['localStorage'] !== null) {
    // postoji podrška za local storage
  } else {
    alert('Nije moguće sačuvati podešavanja jer Vaš čitač nema local storage');
  }
}
          </code></pre></div>
        </section>

        <section class="valigntop left">
          <h2>Primer: test pomoću Modernizr</h2>
          <p class="left">Čitkije pomoću <a href="https://modernizr.com" target="_blank">Modernizr</a>:</p>
          <div style="font-size: 30pt;"><pre><code class="html">​
&lt;script type=&quot;text/javascript&quot; src=&quot;modernizr.min.js&quot;&gt;&lt;/script&gt;
          </code></pre></div>

          <div style="font-size: 30pt;"><pre><code class="javascript">​
if (Modernizr.localstorage) {
  // postoji podrška za local storage
} else {
  alert('Nije moguće sačuvati podešavanja jer Vaš čitač nema local storage');
}
          </code></pre></div>
        </section>

        <section class="valigntop left">
          <h2>Čuvanje podataka: setItem</h2>
          <p class="left">Dodat kod za čuvanje podataka:</p>
          <div style="font-size: 30pt;"><pre><code class="javascript">​
function setSettings() {
  if (Modernizr.localstorage) {
    try {
      var favcolor = document.getElementById('favcolor').value;
      var fontwt = document.getElementById('fontwt').value;
      localStorage.setItem('bgcolor', favcolor);
      localStorage.fontweight = fontwt;
    } catch (e) {
      if (e == QUOTA_EXCEEDED_ERR) { // premašio 10 MB
        alert('Quota exceeded!');
      }
    }
  } else {
    alert('Nije moguće sačuvati podešavanja jer Vaš čitač nema local storage');
  }
}
          </code></pre></div>
        </section>

        <section class="valigntop left">
          <h2>Čitanje podataka: getItem</h2>
          <p class="left">Čitanje iz local storage:</p>
          <div style="font-size: 30pt;"><pre><code class="javascript">​
function applySettings() {
  if (localStorage.length != 0) {
    document.body.style.backgroundColor = localStorage.getItem('bgcolor');
    document.body.style.fontSize = localStorage.fontweight + 'px';
    document.getElementById('favcolor').value = localStorage.bgcolor;
    document.getElementById('fontwt').value = localStorage.fontweight;
  } else {
    document.body.style.backgroundColor = '#FFFFFF';
    document.body.style.fontSize = '13px'
    document.getElementById('favcolor').value = '#FFFFFF';
    document.getElementById('fontwt').value = '13';
  }
}
          </code></pre></div>
          <p class="left"><small><code>length</code> vraća broj sačuvanih elemenata.</small></p>
        </section>

        <section class="valigntop left">
          <h2>Uklanjanje podataka: removeItem</h2>
          <p class="left">Uklanjanje iz local storage:</p>
          <div style="font-size: 30pt;"><pre><code class="javascript">​
function clearSettings() {
  localStorage.removeItem("bgcolor");
  localStorage.removeItem("fontweight");
  document.body.style.backgroundColor = '#FFFFFF';
  document.body.style.fontSize = '13px'
  document.getElementById('favcolor').value = '#FFFFFF';
  document.getElementById('fontwt').value = '13';
}
          </code></pre></div>
        </section>

        <section class="valigntop left">
          <h2>Storage događaji</h2>
          <p class="left">Prilikom upisa ili brisanja, poseban događaj će se desiti za <code>window</code> objekat.  Možemo dodati osluškivanje za taj događaj.</p>
          <div style="font-size: 30pt;"><pre><code class="javascript">​
window.addEventListener('storage', storageEventHandler, false);
function storageEventHandler(event) {
  applySettings();
}
          </code></pre></div>
          <p class="left">Event ima sledeće atribute:</p>
          <ul>
            <li><strong>key</strong>: osobina koja je promenjena</li>
            <li><strong>newValue</strong>: nova vrednost</li>
            <li><strong>oldValue</strong>: stara vrednost</li>
            <li><strong>url</strong>: pun URL gde se događaj desio</li>
            <li><strong>storageArea</strong>: <code>localStorage</code> ili <code>sessionStorage</code> objekat</li>
          </ul>
          <p class="left"><small>Događaj će se desiti samo u drugim prozorima - ne i u prozoru koji ga je izazvao. Desiće se samo ako je došlo do promene u podacima.</small></p>
        </section>

        <section id="efficient">
          <h1>#6: efikasno učitavanje</h1>
        </section>

        <section class="valigntop left">
          <h2>Efikasno učitavanje skriptova</h2>
          <p>Kako web čitači učitavaju sadržaj:</p>
          <ul>
            <li>Parsira HTML dokument redom. Elementi se dodaju u DOM kako se parsiraju. Kako se dodaju u DOM tako se učitavaju (slike, stilovi, skriptovi, itd).</li>
            <li>Čitači mogu učitavati više resursa istovremeno.</li>
            <li>Download eksternog JavaScript fajla će blokirati druga dobavljanja, jer bi skript mogao da promeni DOM, ili da preusmeri čitač na drugu adresu. Čitač neće početi druga paralelna dobavljanja pre nego što se skript preuzme, parsira i izvrši.</li>
          </ul>
        </section>

        <section class="valigntop left">
          <h2>Skript na kraju fajla</h2>
          <p class="left">Skript je zgodno staviti na sam kraj HTML fajla, neposredno ispred <code>&lt;/body&gt;</code> taga. To garantuje da će čitač parsirati ceo fajl i da je DOM spreman pre nego što mu skript pristupi.</p>
          <div style="font-size: 30pt;"><pre><code class="html">​
&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;body&gt;
    &lt;p id=&quot;myParagraph&quot;&gt;This is my paragraph! 
      &lt;span class=&quot;hideme&quot;&gt;Lorem ipsum&lt;/span&gt; 
      dolor sit amet.
    &lt;/p&gt;
    &lt;p class=&quot;hideme&quot;&gt;Another paragraph!&lt;/p&gt;
    &lt;script&gt;
      var myPar = document.getElementById("myParagraph");
      myPar.innerText = "I have changed the content!";
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
          </code></pre></div>
        </section>

        <section class="valigntop left">
          <h2>Skript na početku fajla</h2>
          <p class="left">Ako stavimo skript na početak <code>body</code> počeće da se izvršava pre nego što je dokument u celosti parsiran što može dovesti do greške.</p>
          <div style="font-size: 30pt;"><pre><code class="html">​
&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;body&gt;
    &lt;script&gt;
      var myPar = document.getElementById(&quot;myParagraph&quot;);
      myPar.innerText = &quot;I have changed the content!&quot;;
    &lt;/script&gt;
    &lt;p id=&quot;myParagraph&quot;&gt;This is my paragraph! 
      &lt;span class=&quot;hideme&quot;&gt;Lorem ipsum&lt;/span&gt; 
      dolor sit amet.
    &lt;/p&gt;
    &lt;/p&gt;
    &lt;p class=&quot;hideme&quot;&gt;Another paragraph!&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
          </code></pre></div>
        </section>

        <section class="valigntop left">
          <h2>Tip #1: učitaj skriptove na kraju dokumenta</h2>
          <ul>
            <li>ceo dokument je parsiran</li>
            <li>učitavanje drugih sadržaja (slike, itd) je već počelo</li>
            <li>učitavanje i izvršavanje skripta neće blokirati druge stvari (osim drugih skriptova)</li>
          </ul>

          <p class="left">Šta ako imamo jednostavan dokument koga puno menja skript?</p>
          <ul>
            <li>prikazaće se osnovni (neuređeni) sadržaj</li>
            <li>korisnik neće moći da radi jer je izvršavanje skripta blokiralo čitač</li>
            <li>konačni sadržaj će se prikazati posle pauze</li>
            <li>=&gt; napravi loading screen</li>
          </ul>
        </section>

        <section class="valigntop left">
          <h2>Tip #2: combine, minify, gzip</h2>
          <ul>
            <li>često imamo veliki broj JavaScript fajlova</li>
            <li>veliki broj HTTP zahteva, dugotrajno učitavanje</li>
            <li>=> priprema skriptova za objavljivanje: kombinuj sve u jedan fajl<br/><br/></li>
            <li>u JavaScript kodu ima puno whitespace znakova</li>
            <li>=> ukloni sve nepotrebne znakove<br/><br/></li>
            <li>i nakon toga u pitanju je običan tekst</li>
            <li>=> kompresuj GZip algoritmom koji čitači prepoznaju</li>
          </ul>
        </section>

        <section class="valigntop left">
          <h2>Tip #3: dinamički učitaj skriptove u head</h2>
          <div style="font-size: 30pt;"><pre><code class="javascript">​
var defaultManifest = [
  "scripts/js-lib.js",
  "scripts/js-objects.js",
  "scripts/third-party/omniture.js",
  "http://big.cdn.com/useful-library.js"
]

function loadManifest(arrManifest) {
  var i, arrManifestLength = arrManifest.length;
  for (i = 0; i < arrManifestLength; i++) {
    var newScript = document.createElement("script");
    newScript.src = arrManifest[i];
    document.getElementsByTagName("head")[0].appendChild(newScript);
  }
}
          </code></pre></div>
          <p class="left"><small>Programski kreiramo <code>script</code> tag unutar <code>head</code>.</small></p>
        </section>

        <section class="valigntop left">
          <h2>Tip #3: dinamički učitaj skriptove u head</h2>
          <div style="font-size: 30pt;"><pre><code class="javascript">​
&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;script src=&quot;scripts/js-loader.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
      loadManifest(defaultManifest);
    &lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Hello World!&lt;/h1&gt;
  &lt;/body&gt;
&lt;/html&gt;
          </code></pre></div>
          <p class="left"><small>Sada se skriptovi učitavaju nakon što se programski kreiraju <code>script</code> čvorovi ali to ne blokira učitavanje stranice i drugih elemenata.</small></p>
        </section>

        <section class="valigntop left">
          <h2>Tip #3: dinamički učitaj skriptove u head</h2>
          <ul>
            <li>ceo dokument je parsiran</li>
            <li>učitavanje drugih sadržaja (slike, itd) je već počelo</li>
            <li>učitavanje i izvršavanje skripta neće blokirati druge stvari (osim drugih skriptova)</li>
          </ul>

          <p class="left">Šta ako imamo jednostavan dokument koga puno menja skript?</p>
          <ul>
            <li>prikazaće se osnovni (neuređeni) sadržaj</li>
            <li>korisnik neće moći da radi jer je izvršavanje skripta blokiralo čitač</li>
            <li>konačni sadržaj će se prikazati posle pauze</li>
            <li>=&gt; napravi loading screen</li>
          </ul>
        </section>

        <section id="cors">
          <h1>#7: CORS</h1>
          <h3>Cross-Origin Resource Sharing</h3>
        </section>

        <section class="valigntop left">
          <h2>Same Origin Policy</h2>
          <p>Iz bezbednosnih razloga skriptovi su ograničeni samo na pristup podacima koji imaju isto poreklo (origin). Poreklo je definisano u <a href="https://tools.ietf.org/html/rfc6454" target="_blank">RFC 6454</a> kao kombinacija</p>
          <ul>
            <li>URI šema: http ili https</li>
            <li>hostname</li>
            <li>port</li>
          </ul>
        </section>

        <section class="valigntop left">
          <h2>Same Origin Policy</h2>
          <p>Primer: <strong>http://www.example.com/dir/page.html</strong></p>

          <table style="font-size: 90%">
            <tr>
              <th>URL</th>
              <th>status</th>
              <th>razlog</th>
            </tr>
            <tr>
              <td>http://www.example.com/dir/page2.html</td>
              <td>OK</td>
              <td>isti protokol, host i port</td>
            </tr>
            <tr>
              <td>http://www.example.com/dir2/other.html</td>
              <td>OK</td>
              <td>isti protokol, host i port</td>
            </tr>
            <tr>
              <td>http://username:password@www.example.com/dir2/other.html</td>
              <td>OK</td>
              <td>isti protokol, host i port</td>
            </tr>
            <tr>
              <td>http://www.example.com:81/dir/other.html</td>
              <td>NOK</td>
              <td>različit port</td>
            </tr>
            <tr>
              <td>https://www.example.com/dir/other.html</td>
              <td>NOK</td>
              <td>različit protokol</td>
            </tr>
            <tr>
              <td>http://en.example.com/dir/other.html</td>
              <td>NOK</td>
              <td>različit host</td>
            </tr>
            <tr>
              <td>http://example.com/dir/other.html</td>
              <td>NOK</td>
              <td>različit host</td>
            </tr>
            <tr>
              <td>http://v2.www.example.com/dir/other.html</td>
              <td>NOK</td>
              <td>različit host</td>
            </tr>
            <tr>
              <td>http://www.example.com:80/dir/other.html</td>
              <td>???</td>
              <td>zavisi od browsera</td>
            </tr>
          </table>
        </section>

        <section class="valigntop left">
          <h2>CORS ideja</h2>
          <p><a href="https://www.w3.org/TR/cors/" target="_blank">CORS</a> (Cross-Origin Resource Sharing) pruža mogućnost da sajt <strong>A</strong> dopusti pristup svojim podacima skriptovima sa sajta <strong>B</strong>.</p> 
          <p>Server <strong>A</strong> treba da doda CORS zaglavlja u svoj HTTP odgovor.</p> 
          <p>Podrška za CORS u web čitačima:</p>
          <ul>
            <li>Chrome 3+</li>
            <li>Firefox 3.5+</li>
            <li>Safari 4+</li>
            <li>Opera 12+</li>
            <li>Internet Explorer 8+</li>
            <li>Microsoft Edge</li>
          </ul>
          <p class="left"><small>Tekuće stanje je na <a href="http://caniuse.com/#search=cors" target="_blank">http://caniuse.com/#search=cors</a>.</small></p>
        </section>

        <section class="valigntop left">
          <h2>Priprema XMLHttRequest zahteva</h2>
          <div style="font-size: 30pt;"><pre><code class="javascript">​
function createCORSRequest(method, url) {
  var xhr = new XMLHttpRequest();
  if ("withCredentials" in xhr) { // da li je XMLHttpRequest2 objekat
    xhr.open(method, url, true);
  } else if (typeof XDomainRequest != "undefined") {
    // XDomainRequest: specijalan slučaj za MSIE
    xhr = new XDomainRequest();
    xhr.open(method, url);
  } else {
    xhr = null; // CORS nije podržan
  }
  return xhr;
}

var xhr = createCORSRequest('GET', url);
if (!xhr) {
  throw new Error('CORS not supported');
}
          </code></pre></div>
        </section>

        <section class="valigntop">
          <h2>Priprema XMLHttpRequest zahteva</h2>
          <p class="left">Treba definisati callback za <code>onload</code> i <code>onerror</code>.</p>
          <div style="font-size: 30pt;"><pre><code class="javascript">​
xhr.onload = function() {
  var responseText = xhr.responseText;
  console.log(responseText);
  // obradi odgovor
};

xhr.onerror = function() {
  console.log('Greška!');
};
          </code></pre></div>
        </section>

        <section class="valigntop">
          <h2>Priprema XMLHttpRequest zahteva</h2>
          <p class="left">Standardni CORS zahtevi ne podrazumevaju cookies. Za uključivanje cookies treba:</p>
          <div style="font-size: 30pt;"><pre><code class="javascript">​
xhr.withCredentials = true;
          </code></pre></div>
          <p class="left">Server sa svoje strane mora da omogući credentials odgovarajućim zaglavljem:</p>
          <div style="font-size: 30pt;"><pre><code class="javascript">​
Access-Control-Allow-Credentials: true
          </code></pre></div>
          <p class="left">Ovi cookies neće biti dostupni u JavaScriptu zbog SOP.</p>
        </section>

        <section class="valigntop">
          <h2>Slanje CORS zahteva</h2>
          <p class="left">Kada je sve pripremljeno:</p>
          <div style="font-size: 30pt;"><pre><code class="javascript">​
xhr.send();
          </code></pre></div>
          <p class="left">Ako zahtev ima telo, ono se prosleđuje kao parametar <code>send</code>.</p>
        </section>

        <section class="valigntop">
          <h2>CORS na serveru</h2>
          <p class="left">Najveći posao će obaviti web čitač i server. Čitač će dodati zaglavlja i po potrebi slati dodatne zahteve.</p>
          <img src="img/javascript/cors-flow.png" width="50%" style="background:white" />
        </section>

        <section class="valigntop left">
          <h2>Prosti CORS zahtevi</h2>
          <p class="left">Prosti CORS zahtevi imaju:</p>
          <ul>
            <li>GET, HEAD ili POST</li>
            <li>Accept</li>
            <li>Accept-Language</li>
            <li>Content-Language</li>
            <li>Last-Event-ID</li>
            <li>Content-Type koji mora biti
              <ul>
                <li>application/x-www-form-urlencoded</li>
                <li>multipart/form-data</li>
                <li>text/plain</li>
              </ul>
            </li>
          </ul>
        </section>

        <section class="valigntop">
          <h2>Prosti CORS zahtev</h2>
          <div style="font-size: 30pt;"><pre><code class="javascript">​
var url = 'http://api.alice.com/cors';
var xhr = createCORSRequest('GET', url);
xhr.send();
          </code></pre></div>
          <div style="font-size: 30pt;"><pre><code class="text">​
GET /cors HTTP/1.1
Origin: http://api.bob.com
Host: api.alice.com
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
          </code></pre></div>
          <p class="left"><code>Origin</code> zaglavlje je dodao čitač i ne može se uticati na njega!</p>
        </section>

        <section class="valigntop left">
          <h2>Odgovor servera</h2>
          <div style="font-size: 30pt;"><pre><code class="javascript">​
Access-Control-Allow-Origin: http://api.bob.com
Access-Control-Allow-Credentials: true
Access-Control-Expose-Headers: FooBar
Content-Type: text/html; charset=utf-8
...
          </code></pre></div>
          <ul>
            <li><strong>Access-Control-Allow-Origin</strong> (obavezan): mora biti uključen u sve CORS odgovore; sadrži ili adresu iz zahteva ili <code>*</code> (za sve domene)</li>
            <li><strong>Access-Control-Allow-Credentials</strong> (opcioni): naznačava da treba uključiti cookies u zahteve</li>
            <li><strong>Access-Control-Expose-Headers</strong> (opcioni): dodatna zaglavlja koja su dostupna klijentu (pored standardnih Cache-Control, Content-Language, Content-Type, Expires, Last-Modified, Pragma)</li>
          </ul>
        </section>

        <section class="valigntop left">
          <h2>Složeni zahtevi</h2>
          <p>Složeni zahtevi su potrebni ako šaljemo druge metode kao PUT i DELETE ili ako prenosimo JSON podatke.</p>
          <div style="font-size: 30pt;"><pre><code class="javascript">​
var url = 'http://api.alice.com/cors';
var xhr = createCORSRequest('PUT', url);
xhr.setRequestHeader('X-Custom-Header', 'value');
xhr.send();
          </code></pre></div>
          <p>Čitač prvo šalje probni zahtev (OPTIONS) da proveri da li ima dozvolu da šalje pravi zahtev. Posle pozitivnog odgovora šalje pravi zahtev. Ovo se odvija transparentno za JavaScript program. Probni zahtev se može keširati da se ne bi slao više puta.</p>
        </section>

        <section class="valigntop left">
          <h2>Probni zahtev</h2>
          <div style="font-size: 30pt;"><pre><code class="text">​
OPTIONS /cors HTTP/1.1
Origin: http://api.bob.com
Access-Control-Request-Method: PUT
Access-Control-Request-Headers: X-Custom-Header
Host: api.alice.com
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
          </code></pre></div>
          <ul>
            <li><strong>Access-Control-Request-Method</strong>: metoda pravog zahteva</li>
            <li><strong>Access-Control-Request-Headers</strong>: lista posebnih zaglavlja u zahtevu, razdvojenih zarezom</li>
          </ul>
        </section>

        <section class="valigntop left">
          <h2>Odgovor na probni zahtev</h2>
          <div style="font-size: 30pt;"><pre><code class="text">​
Access-Control-Allow-Origin: http://api.bob.com
Access-Control-Allow-Methods: GET, POST, PUT
Access-Control-Allow-Headers: X-Custom-Header
Content-Type: text/html; charset=utf-8
          </code></pre></div>
          <ul>
            <li><strong>Access-Control-Allow-Origin</strong>: kao kod prostog zahteva</li>
            <li><strong>Access-Control-Allow-Methods</strong>: lista dozvoljenih HTTP metoda</li>
            <li><strong>Access-Control-Allow-Headers</strong>: lista dozvoljenih zaglavlja u zahtevu</li>
            <li><strong>Access-Control-Allow-Credentials</strong>: kao kod prostog zahteva</li>
            <li><strong>Access-Control-Max-Age</strong>: omogućava keširanje ovog odgovora dati broj sekundi</li>
          </ul>
        </section>

        <section class="valigntop left">
          <h2>Stvarni zahtev</h2>
          <div style="font-size: 30pt;"><pre><code class="text">​
PUT /cors HTTP/1.1
Origin: http://api.bob.com
Host: api.alice.com
X-Custom-Header: value
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
          </code></pre></div>
        </section>

        <section class="valigntop left">
          <h2>Odgovor na stvarni zahtev</h2>
          <div style="font-size: 30pt;"><pre><code class="text">​
Access-Control-Allow-Origin: http://api.bob.com
Content-Type: text/html; charset=utf-8
          </code></pre></div>
          <p>Ako se izostave CORS zaglavlja, signalizira se neispravan zahtev.</p>
        </section>

        <section class="valigntop">
          <h2>Koja zaglavlja staviti u odgovor?</h2>
          <a href="img/javascript/cors-server-flowchart.png" target="_blank"><img src="img/javascript/cors-server-flowchart.png" width="50%" style="border:0"></a>
        </section>

        <section>
          <h3>Kraj dela</h3>
          <p><a href="#/">← Početak dela</a></p>
          <p><a href="index.html#/1">⇐ Početak kursa</a></p>
        </section>

      </div>
    </div>
    <div id="overlay"></div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>
      // More info https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        history: true,

        // 16:9 aspect ratio
        width: 1280,
        height: 720,
        margin: 0.02,

        // don't piss people off
        transition: 'none',

        // More info https://github.com/hakimel/reveal.js#dependencies
        dependencies: [
          { src: 'plugin/markdown/marked.js' },
          { src: 'plugin/markdown/markdown.js' },
          { src: 'plugin/notes/notes.js', async: true },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
        ]
      });

      // moze i pomocu
      // window.onhashchange = function() {
      //   ...
      // }
      Reveal.addEventListener('slidechanged', function(event) {
        var overlayDiv = document.getElementById("overlay");
        var currSlide = Reveal.getCurrentSlide();
        var overlayImg = currSlide.getAttribute("overlay");
        if (overlayImg != null) {
          alert('x');
          overlayDiv.style.display = 'block';
          overlayDiv.style.backgroundImage = 'url("' + overlayImg + '")';
          overlayDiv.style.zIndex = 1;
        } else {
          overlayDiv.style.display = 'none';
          overlayDiv.style.zIndex = -1;
        }
      });

    </script>
  </body>
</html>
